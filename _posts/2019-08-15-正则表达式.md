# 正则表达式
由一系列的元字符和普通字符组成的字符串根据一定规则来匹配文本
元字符是正则表达式中的保留字符，比如*代表匹配0到无穷多次，普通字符就是普通的abcd等。
## 正则表达式中的元字符
**匹配单个字符的元字符**
+ .代表匹配一个任意字符，除了\n换行符
+ [...]表示字符组，只匹配其中一个。
+ [^...]和[...]含义相反，它的意思是匹配一个不属于[...]里面的字符   

**提供计数功能的元字符**
+ *代表匹配0次到无穷次，可以不匹配任何字符
+ +代表匹配1次到无穷次，至少匹配1次
+ ?代表匹配0次或1次
+ {min, max}代表匹配min次到max次，如a{3, 5}表示a至少匹配3-5次             

**提供位置的元字符**
+ ^代表匹配字符串开头，如^a表示a要出现在字符串开头，bcd则不匹配
+ $代表匹配字符串结尾, 如A$表示A要出现在字符串结尾，ABAB则不匹配

**其他元字符**
+ \|代表一个范围，可以匹配任意的子表达式，比如abc\|def可以匹配abc或者def，不匹配abd
+ (...)代表分组，它的作用有界定子表达式的范围和与提供功能的元字符相结合，比如(abc\|def)+代表可以匹配1次或1次以上的abc或者defdef，如abcabcabc，def
+ \i代表反向引用，i可以为1/2/3等整数，它的含义是指向上一个()里面匹配的内容。比如匹配(abc)+(12)*\1\2，如果匹配成功的话，\1的内容是abc，\2的内容是12或者空。反向引用通常用在匹配""或者''中

**环视**
我理解的环视是界定当前匹配子表达式的左边文本和右边文本出现的情况，环视本身不会占据匹配的字符，它是当前子表达式的匹配规则但是本身不算进匹配文本。而我们上面说的元字符都代表一定的规则和占据一定的字符。环视可分为四种：肯定顺序环视、否定顺序环视、肯定逆序环视和否定逆序环视。它们的工作流程如下：
+ 肯定顺序环视：先找到环视中的文本在右侧出现的初始位置，然后从匹配到的右侧文本的最左的位置开始匹配字符
+ 否定顺序环视：先找到环视中的文本在右侧没有出现的初始位置，然后从匹配到的右侧文本的最左的位置开始匹配字符
+ 肯定逆序环视：先找到环视中的文本在左侧出现的初始位置，然后从匹配到的左侧文本的最右的位置开始匹配字符
+ 否定逆序环视：先找到环视中的文本在左侧没有出现的初始位置，然后从匹配到的左侧文本的最右的位置开始匹配字符

**肯定顺序环视**
肯定顺序环视匹配成功的条件是当前的子表达式能够匹配右侧文本，它的写法是(?=...),...代表要环视的内容。比如正则表达式(?=hello)he的意思是匹配包含hello的文本，它只匹配位置，不匹配具体字符，匹配到位置之后，才真正匹配要占用的字符是he，所以后面可以具体匹配llo等。

**否定顺序环视**
否定顺序环视匹配成功的条件是当前的子表达式不能匹配右侧文本，它的写法是(?!...),...代表要环视的内容，还是上面的例子，比如正则表达式(?!hello)he的意思是匹配不是hello的文本，找到位置，然后匹配he。

**肯定逆序环视**
肯定逆序环视匹配成功的条件是当前的子表达式能够匹配左侧文本，它的写法是(?<=...),...代表要环视的内容，比如正则表达式(?<=hello)-python的意思是匹配包含-python的子表达式，并且它的左侧必须出现hello，hello只匹配位置，不匹配具体字符，真正占用的字符是后面的-python。

环视在对字符串插入某些字符很有效，你可以利用它来匹配位置，然后插入对应的字符，而不需要对原来的文本进行替换。

**捕获分组**

在正则表达式中，分组可以帮助我们提取出想要的特定信息。

指明分组很简单，只需要在想捕获的表达式中两端加上()就可以了。在python中，我们可以用re.search(reg, xx).groups()来获取到所有的分组。
默认的()中都指明了一个分组，分组序号为i，i从1开始，分别用re.search(reg, xx).group(i)来获取。

如果不想捕获分组可以使用(?:...)来指明。

**贪婪匹配**
贪婪匹配是指正则表达式尽可能匹配多的字符，也就是趋于最大长度匹配。
正则表达式默认是贪婪模式。
非贪婪匹配正好与贪婪匹配相反，它是指尽可能匹配少的字符，只要匹配到了就结束。要使用贪婪模式，仅需要在量词后面加上一个问号(?)就可以。